import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e,o as t}from"./app-BVUN0Yve.js";const l="/assets/66678-CUJOfAyB.jpg",n="/assets/image-20250228130332109-BbonSYC-.png",h="/assets/image-20250301131940330-SVJOcqLs.png",k="/assets/image-20250301134625044-6NkA5jb8.png",p="/assets/image-20250301140633665-JuIDZYwB.png",d="/assets/image-20250301152203928-Deha_Oix.png",r="/assets/image-20250301152459463-CXN_B9f7.png",c="/assets/image-20250301155208732-CdHxiuA7.png",g="/assets/image-20250301155421851-DbGarJj7.png",A={};function o(B,i){return t(),a("div",null,i[0]||(i[0]=[e('<h1 id="一些补充" tabindex="-1"><a class="header-anchor" href="#一些补充"><span>一些补充</span></a></h1><p>这次主要是补齐一些之前没讲的内容。</p><h2 id="null-check" tabindex="-1"><a class="header-anchor" href="#null-check"><span>Null Check</span></a></h2><h2 id="文件-i-o" tabindex="-1"><a class="header-anchor" href="#文件-i-o"><span>文件 I/O</span></a></h2><p>C#提供了丰富的文件操作相关的API。</p><h3 id="简单方便的文件读写操作" tabindex="-1"><a class="header-anchor" href="#简单方便的文件读写操作"><span>简单方便的文件读写操作</span></a></h3><p><code>System.IO</code>命名空间下的<code>File</code>类为我们提供了非常简单的文件读写方式。你可以在<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.file" target="_blank" rel="noopener noreferrer">文档中</a>找到接下来要用到的各个方法的用法，这里不详细介绍了。</p><h4 id="写入" tabindex="-1"><a class="header-anchor" href="#写入"><span>写入</span></a></h4><p>只需要使用<code>File.WriteAllLines</code>/<code>File.WriteAllBytes</code>/<code>File.WriteAllText</code>（或者它们的async版本）就可以轻松完成。不需要任何其它代码，只需要在参数中填上文件路径、要写入的内容就可以了，这几个方法会自动创建文件（如果文件已经存在的话会删除原来文件的内容）。</p><table><thead><tr><th style="text-align:left;">方法名</th><th style="text-align:left;">用途</th><th style="text-align:left;">主要参数</th><th style="text-align:left;">处理的数据类型</th><th style="text-align:left;">适用场景</th><th style="text-align:left;">编码处理</th></tr></thead><tbody><tr><td style="text-align:left;"><code>File.WriteAllLines</code></td><td style="text-align:left;">写入多行文本</td><td style="text-align:left;"><code>路径</code>, <code>字符串集合</code>（如数组或列表）, <code>编码</code>（可选）</td><td style="text-align:left;">字符串集合（逐行处理）</td><td style="text-align:left;">多行文本（日志、配置文件等）</td><td style="text-align:left;">支持指定，默认 UTF-8</td></tr><tr><td style="text-align:left;"><code>File.WriteAllBytes</code></td><td style="text-align:left;">写入二进制数据</td><td style="text-align:left;"><code>路径</code>, <code>字节数组</code></td><td style="text-align:left;">字节数组（原始二进制）</td><td style="text-align:left;">非文本文件（图片、音频、加密数据）</td><td style="text-align:left;">无，直接写入字节</td></tr><tr><td style="text-align:left;"><code>File.WriteAllText</code></td><td style="text-align:left;">写入单个字符串</td><td style="text-align:left;"><code>路径</code>, <code>字符串</code>, <code>编码</code>（可选）</td><td style="text-align:left;">单个字符串</td><td style="text-align:left;">单一文本块（JSON、XML、HTML 等）</td><td style="text-align:left;">支持指定，默认 UTF-8</td></tr></tbody></table><p>以上三个方法都会覆盖文件，如果想要在原来的文件后面添加内容，可以使用对应的Append版本（ <code>File.AppendAllLines</code> / <code>File.AppendAllBytes</code> / <code>File.AppendAllText</code>）</p><blockquote><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteAllText</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;test.txt&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>写入一个<code>Hello, World!</code>，并且多次执行文件中也只有一个<code>Hello, World!</code>，因为每次<code>WriteAllText</code>都会覆盖原来的文件。</p><p>如果使用<code>AppendAllText</code>，则不会覆盖原来的文件，会在后面添加内容。</p></blockquote><h4 id="读取" tabindex="-1"><a class="header-anchor" href="#读取"><span>读取</span></a></h4><p>以上三个方法也有对应的<code>Read</code>版本（<code>File.ReadAllLines</code>/<code>File.ReadAllBytes</code>/<code>File.ReadAllText</code>）。</p><p>但是除了这三个方法，还多了一个<code>File.ReadLines</code>，看起来和<code>ReadAllLines</code>很像。它们最大的区别在于是否完全读取文件的内容，这体现在它们的返回值类型上——</p><ul><li><p><code>ReadAllLines</code>返回一个<code>string[]</code>。</p></li><li><p><code>ReadLines</code>返回一个<code>IEnumerable&lt;string&gt;</code>，这意味着它会一行一行读取文本，在处理巨大的文件时不需要把文件完整的读取到内存后再返回结果，会提高效率。</p></li></ul><h3 id="更复杂的流式i-o" tabindex="-1"><a class="header-anchor" href="#更复杂的流式i-o"><span>更复杂的流式I/O</span></a></h3><p>上面提到的简单的文件读写方法可以解决简单的问题，但是很显然它不够灵活，只能以文件为单位读写，而做不到修改/删除文件的某一小部分。</p><p>上面三个方法一样得读取整个文件到内存中（对于<code>ReadLines</code>，则是读取一行）后我们才能开始处理。编写的程序很可能需要和非常巨大的文件打交道，要是读取整个文件到内存中，用户的电脑恐怕都没有足够的内存放下全部数据！因此，我们需要一种更灵活的方式处理数据——流（Stream）。</p><h4 id="什么是流" tabindex="-1"><a class="header-anchor" href="#什么是流"><span>什么是<strong>流</strong>？</span></a></h4><p>你可能已经在许多地方听过“流”了，尤其是音视频领域的一些词汇——直播推流，流媒体等等。如果你使用C++打过算法竞赛，那么肯定对<code>std::cin</code>、<code>std::cout</code>、以及头文件<code>iostream</code>不陌生，它们是标准输入输出流。</p><p>那么，什么是流呢？</p><p>吃过回转寿司吗？不同的寿司在传送带上围绕坐台运行。你可以把寿司想象成数据，而这个传送带就是流。我们可以：</p><ul><li>拿取传送带上的寿司</li><li>把吃完的盘子放回去</li><li>选择你想吃的寿司</li></ul><figure><img src="'+l+'" alt="66678" tabindex="0" loading="lazy"><figcaption>66678</figcaption></figure><p>这分别代表着流的三种操作：</p><h5 id="流的操作" tabindex="-1"><a class="header-anchor" href="#流的操作"><span>流的操作</span></a></h5><p>流有三种操作，分别是<code>Read</code>（读）、<code>Write</code>（写）和<code>Seek</code>（随机访问）。</p><p>如果有人翻开过<code>Console.WriteLine()</code>的源码的话，就会发现它和C++的<code>std::cout</code>一样，是封装好的对流的操作。我们向这个 text stream 写入文字，文字就会出现在终端上。这就是<code>Write</code>。当然，<code>Console.ReadLine()</code>也是类似的，从终端的 text stream 读取文字。</p><figure><img src="'+n+'" alt="image-20250228130332109" tabindex="0" loading="lazy"><figcaption>image-20250228130332109</figcaption></figure><p>对于一部分流，我们可以控制它去读取我们想要的部分。这种操作叫做<code>Seek</code>，它可以改变流的位置（Position），它通常常见于那些用来读取已经存在了的数据的流上，e.g.用来读写文件的文件流，可以通过<code>Seek()</code>自由控制接下来从文件的哪个部分读取数据。</p><p>一个流至少实现读或写中的一种操作。这三个操作让流可以非常灵活的处理数据，而我们即将讲到的文件流<code>FileStream</code>则同时支持这三种操作（如果以读写模式打开文件的话）。</p><h5 id="流的分类" tabindex="-1"><a class="header-anchor" href="#流的分类"><span>流的分类</span></a></h5><p>根据流支持的操作，我们可以将其分为两类：读取流和写入流</p><p>如果一个流同时支持读和写，那么它既是读取流也是写入流。</p><h5 id="流的连续性" tabindex="-1"><a class="header-anchor" href="#流的连续性"><span>流的连续性</span></a></h5><p>流只有一个核心特征：连续性。</p><p>流就像小溪里的水流一样，里面的数据是连绵不绝的。它甚至可以没有开头，也可以没有结尾，只需要一边不断产生数据，然后流动到另一边处理。</p><h5 id="流的使用" tabindex="-1"><a class="header-anchor" href="#流的使用"><span>流的使用</span></a></h5><p>概念讲完了，该来点更实际的了——代码该怎么写？</p><p>我需要一个方便演示的，不会引入其它复杂因素的，同时支持三种操作的流来做演示。<code>MemoryStream</code>内存流是一个不错的选择。它可以用来读取存放在内存里的一块数据（也就是<code>byte[]</code>字节数组），换句话说，<code>byte[]</code>就是数据的来源，不断产生数据，然后我们可以从这个流里读取它产生的数据（写入也行）。</p><figure><img src="'+h+`" alt="image-20250301131940330" tabindex="0" loading="lazy"><figcaption>image-20250301131940330</figcaption></figure><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> memory</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    0x31</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x33</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x34</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x35</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x36</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x37</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    0x38</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x39</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 是 1 2 3 4 5 6 7 8 9 0 0 0 0 0 对应的 ASCII 码，</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 以十六进制呈现</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> stream</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MemoryStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">memory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 创建一个用来操作 byte[] memory 的 MemoryStream</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始时，<code>MemoryStream</code>的位置位于开头，即会从字节数组的第一个值开始读取。</p><h5 id="读取-1" tabindex="-1"><a class="header-anchor" href="#读取-1"><span>读取</span></a></h5><p>我们读取前9个字节：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 读取九个字节</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> stream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    offset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Encoding</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">ASCII</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)); </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 把字节按ASCII码转换成字符串输出</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出 123456789</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$&quot;Read {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">byte_read</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">} bytes&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出 Read 9 bytes （即成功读取了 9 个字节）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用<code>Stream.Read</code>方法来读取。我们需要有一个字节数组作为buffer（缓冲区），用来存放读取到的东西。然后，是<code>offset</code>参数，它控制读取到的数据存放在<code>buffer</code>的什么位置。稍后会说为什么要这么做。<code>count</code>，就是从流里读取多少字节。这里读9个字节。最后，函数的返回值是一个<code>int</code>，表示实际读取到了几个字节。读取时，流的位置也会移动。</p><figure><img src="`+k+`" alt="image-20250301134625044" tabindex="0" loading="lazy"><figcaption>image-20250301134625044</figcaption></figure><h5 id="移动" tabindex="-1"><a class="header-anchor" href="#移动"><span>移动</span></a></h5><p>我们可以使用<code>Seek</code>来移动流的位置。用法很简单，只有两个参数：</p><ul><li><code>offset</code>：相对<code>origin</code>参数指定的位置移动多少字节</li><li><code>origin</code>: <code>SeekOrigin</code>枚举。三个选项：相对于开头、相对于结尾、相对于当前位置。</li></ul><h5 id="写入-1" tabindex="-1"><a class="header-anchor" href="#写入-1"><span>写入</span></a></h5><p><code>Write</code>和<code>Read</code>类似，同样是三个参数：</p><ul><li><code>byte[] buffer</code>： 写入什么东西</li><li><code>int offset</code>： 从<code>buffer</code>的哪里读取东西写入</li><li><code>int count</code>： 写入多少字节</li></ul><p>不过，<code>Write</code>没有返回值</p><h5 id="多次读取" tabindex="-1"><a class="header-anchor" href="#多次读取"><span>多次读取</span></a></h5><p>前面提到了<code>offset</code>参数。有时，一次读取没法完整读取全部内容（比如下载文件），需要多次读取，最后把所有读取到的内容合并到一个<code>Byte[]</code>数组里。<code>offset</code>可以完成这件事。通过偏移写入的位置，它可以<strong>避免覆盖缓冲区中已有的数据</strong>，进而允许我们<strong>在同一缓冲区的不同位置存储多次读取的数据</strong>，而无需每次都创建新的缓冲区。</p><p>对前面的代码做改造，我们每次读取1字节，最终完整读取这个流：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">stream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// +1 是因为读取完毕后还要再读取一个字节</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 已读取的字节数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> current_byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">current_byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    current_byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> stream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> +=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> current_byte_read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    Console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Encoding</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">ASCII</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    Console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$&quot;Read {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">byte_read</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">} bytes, and this time read {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">current_byte_read</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">} bytes. Current position: {</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">stream</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Position</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+p+`" alt="image-20250301140633665" tabindex="0" loading="lazy"><figcaption>image-20250301140633665</figcaption></figure><p>可以看见每次都读取了一个字节，读取完毕后还执行了一次读取，但是最后这次读取没能读取到任何东西（流已经读完了！），因此我们将其作为循环结束的条件。</p><h4 id="文件流" tabindex="-1"><a class="header-anchor" href="#文件流"><span>文件流</span></a></h4><p>文件流（<code>FileStream</code>）是 C# 中用于直接操作文件的底层流类型。它提供了对文件的<strong>细粒度控制</strong>，允许开发者按字节读写（<code>Read</code>,<code>Write</code>）、随机访问（<code>Seek</code>）以灵活处理大文件。它使用起来会麻烦一些，但是我们通常不需要去对流做多么复杂的操作，只需要创建一个流，用别人写好的方法读取流里面的数据，然后释放一个流就完成了。前面提到的简单的文件读写方法就是对文件流的封装。</p><h5 id="创建文件流" tabindex="-1"><a class="header-anchor" href="#创建文件流"><span>创建文件流</span></a></h5><p>创建 <code>FileStream</code> 时需要指定文件路径、操作模式（<code>FileMode</code>）、访问权限（<code>FileAccess</code>）等参数。</p><table><thead><tr><th style="text-align:left;">参数名</th><th style="text-align:left;">类型</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;"><code>FileMode</code></td><td style="text-align:left;">枚举</td><td style="text-align:left;">控制文件打开方式（创建、覆盖、追加等）</td></tr><tr><td style="text-align:left;"><code>FileAccess</code></td><td style="text-align:left;">枚举</td><td style="text-align:left;">控制读写权限（读、写、读写）</td></tr><tr><td style="text-align:left;"><code>FileShare</code></td><td style="text-align:left;">枚举</td><td style="text-align:left;">控制其他进程对文件的访问权限</td></tr><tr><td style="text-align:left;"><code>bufferSize</code></td><td style="text-align:left;">int</td><td style="text-align:left;">缓冲区大小（提升性能）</td></tr></tbody></table><p>以上几个枚举的所有可能值请自行查阅文档/使用IDE的补全功能获得。</p><h5 id="读取文件流" tabindex="-1"><a class="header-anchor" href="#读取文件流"><span>读取文件流</span></a></h5><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;test2.txt&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">FileMode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Open</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> reader</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">StreamReader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> text</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> reader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ReadToEnd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用<code>StreamReader</code>来读取这个文件流的内容。它为我们封装好了对流的读取操作，用起来很方便，就像前面提到的简单的文件读写方法一样。当然，如果你想使用流最基础的的<code>Read()</code>和<code>Seek()</code>来完成，也是没问题的：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;test2.txt&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">FileMode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Open</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">entireFile</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 所有数据在计算机中最终都是以字节形式存储的，因此我们使用byte[]字节数组来存放读取到的文件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Seek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">SeekOrigin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 把流的位置移动到开头</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">entireFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">entireFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 完整读取到entireFile数组里</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Encoding</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">UTF8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">entireFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="销毁文件流" tabindex="-1"><a class="header-anchor" href="#销毁文件流"><span>销毁文件流</span></a></h5><p>你可能发现了，在结尾使用了<code>Close()</code>方法来关闭一个文件流。这很重要！文件是操作系统提供的资源，获取并使用完毕后，我们需要及时释放它。文件流（<code>FileStream</code>）本质是操作系统资源的句柄（Handle）。如果不显式关闭流：</p><ul><li><strong>文件锁定</strong>：其他程序无法访问该文件（直到你的程序结束）</li><li><strong>内存泄漏</strong>：未释放的流会持续占用内存</li><li><strong>数据丢失风险</strong>：缓冲区的数据可能未完全写入磁盘</li></ul><p>很多资源都是如此，需要使用完毕就释放。对于这种资源，C#中有一个接口<code>IDisposable</code>来描述。</p><h5 id="idisposable-接口" tabindex="-1"><a class="header-anchor" href="#idisposable-接口"><span><code>IDisposable</code> 接口</span></a></h5><p><code>IDisposable</code>是一个关于资源释放的接口，它只由一个方法构成：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> IDisposable</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Dispose</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 用于释放资源</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>核心作用</strong>：约定实现类必须提供资源释放方法</li><li><strong>适用对象</strong>：所有需要手动释放的非托管资源（文件句柄、数据库连接、网络端口等）</li></ul><p><code>FileStream</code>实现了<code>IDisposable</code>接口，因此我们也可以使用<code>Dispose()</code>方法来释放文件资源。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Dispose</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 等价于</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// FileStream.Dispose() 的内部实现：</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// public void Dispose() =&gt; Close();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是很多程序员会忘掉释放这些资源，所以C#提供了一个能帮我们自动调用<code>Dispose()</code>释放的机制——<code>using</code></p><h5 id="using代码块" tabindex="-1"><a class="header-anchor" href="#using代码块"><span><code>using</code>代码块</span></a></h5><p><code>using</code> 代码块可以实现自动化资源管理。代码块执行完毕后，它会帮我们执行<code>IDisposable.Dispose()</code>方法，这样就不会忘掉释放了🥰</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fs</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;file.txt&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">FileMode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Open</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 使用流...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 此处自动调用 fs.Dispose()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，很多人觉得代码块很丑，所以也有不需要代码块的写法：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fs</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;file.txt&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">FileMode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Open</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 作用域结束时自动释放（无需大括号块）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>using</code>是RAII（资源获取即初始化）思想的体现。对象创建时获取资源（比如<code>FileStream</code>内部调用打开文件的接口，获取的操作系统的文件资源），然后在不需要该对象时自动释放这个资源。</p><ul><li><strong>核心思想</strong>：将资源与对象的生命周期绑定 <ul><li><strong>对象创建时</strong> 获取资源（构造函数）</li><li><strong>对象销毁时</strong> 自动释放资源（Dispose）</li></ul></li></ul><p>如果你的类拥有一个需要释放的资源，<u>你也应该让你的类实现<code>IDisposable</code>接口</u>，在<code>Dispose</code>方法中实现释放资源的逻辑。这样，在使用这个类时，只需要使用<code>using</code>即可完成资源的自动释放。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">IDisposable</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    FileStream</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        fs</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">FileMode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Open</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Dispose</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Dispose</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="x-bind的一些高级用法" tabindex="-1"><a class="header-anchor" href="#x-bind的一些高级用法"><span><code>x:Bind</code>的一些高级用法</span></a></h2><h3 id="函数绑定" tabindex="-1"><a class="header-anchor" href="#函数绑定"><span>函数绑定</span></a></h3><p><code>x:Bind</code>不只是支持绑定到一个属性，还能把这个属性作为一个函数的参数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{x:Bind Function(Value1, Value2)}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>{x:Bind}</code>的函数绑定解决了以前传统的<code>{Binding}</code>的不少痛点——写多重绑定和Converter，以及字符串格式化。现在，这些都可以在后台代码的函数中轻松完成。</p><p>用一个简单的页面来演示：</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">StackPanel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">TextBlock</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{x:Bind ViewModel.Name, Mode=OneWay}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">TextBox</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{x:Bind ViewModel.Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">StackPanel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有一个文本块和输入文本框，输入的内容会显示到文本块中：</p><figure><img src="`+d+`" alt="image-20250301152203928" tabindex="0" loading="lazy"><figcaption>image-20250301152203928</figcaption></figure><p>但是我希望文本块显示的是类似于&quot;Hello, Shirasagi!&quot;这样的语句，我们可以使用一个函数来帮我们转换：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// MainPage.xaml.cs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GreetingConvert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> $&quot;Hello, {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">}!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，接着使用函数绑定，把<code>ViewModel.Name</code>作为函数的<code>name</code>参数。</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">TextBlock</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{x:Bind {x:Bind Input.Text}}, Mode=OneWay}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="`+r+`" alt="image-20250301152459463" tabindex="0" loading="lazy"><figcaption>image-20250301152459463</figcaption></figure><p>这就是函数绑定，它可以用来转换数据。并且，数据绑定更新仍然正常工作。如果参数里有多个可观察对象，那么只要有一个更新，就会重新计算值。</p><p>函数绑定的参数也可以是常数（如数字<code>123</code>或者字符串<code>&#39;Hello!&#39;</code>，或者其它资源，或者手写<code>MarkupExtension</code>），但说实话不太方便，不如针对某个<code>x:Bind</code>单独写一个不需要其它参数的函数。</p><p>但是有一些值得注意的局限性：</p><ul><li>它不支持泛型函数</li><li>它的参数不能是另一个函数（<code>{x:Bind Func1(Func2(ViewModel.Property1))}</code>是不行的 × ）</li><li>会导致隐性数据转换不工作（比如<code>Visibility</code>属性一般会把<code>bool</code>类型转换成<code>Visibility</code>枚举，但是如果是函数返回的<code>bool</code>就不会转换，需要手动转换一次。</li></ul><h3 id="事件绑定" tabindex="-1"><a class="header-anchor" href="#事件绑定"><span>事件绑定</span></a></h3><p>一般我们写事件处理程序是这样写：<code>&lt;Button Click=&quot;ButtonBase_OnClick&quot; /&gt;</code></p><p>但是这样写只能绑定到后台代码里的函数，使用<code>{x:Bind}</code>可以绑定到其它地方（比如<code>ViewModel</code>）里的函数：</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Button</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Click</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{x:Bind ViewModel.ButtonBase_OnClick}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="属性查找" tabindex="-1"><a class="header-anchor" href="#属性查找"><span>属性查找</span></a></h3><p>你可能会在编写<code>DataTemplate</code>时遇到一个问题，<code>{x:Bind}</code>找不到<code>DataTemplate</code>外面的值！比如我们的ViewModel中有个<code>Text</code>属性，那么这样的代码是不行的🙅‍会因为<code>{x:Bind}</code>找不到<code>Text</code>属性而报错</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ItemsRepeater</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> ItemsSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{x:Bind ViewModel.Items}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ItemsRepeater.ItemTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">DataTemplate</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> x:DataType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;model:TestModel&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">TextBlock</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{x:Bind ViewModel.Text}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">DataTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ItemsRepeater.ItemTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ItemsRepeater</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+c+'" alt="image-20250301155208732" tabindex="0" loading="lazy"><figcaption>image-20250301155208732</figcaption></figure><p>这是因为在<code>DataTemplate</code>（以及<code>ControlTemplate</code>中），<code>{x:Bind}</code>的查找范围被限定在<code>x:DataType</code>/<code>TargetType</code>的类型中，自然就找不到后台代码里的值了。问题的解决方法可以参考这个：<a href="https://poker-sang.github.io/WinUI/%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/XAML%E7%9B%B8%E5%85%B3/XAML%E4%B8%ADDataTemplate%E5%8F%98%E9%87%8F%E9%9A%90%E8%97%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener noreferrer">Poker-sang | XAML的DataTemplate如何调用外部的属性（变量遮盖）</a></p><p>那么<code>{x:Bind}</code>的查找范围是怎样确定的呢？</p><ul><li>一个<code>xaml</code>文件是一个查找范围，除非： <ul><li>在<code>DataTemplate</code>和<code>ContentTemplate</code>内</li></ul></li><li>对于<code>xaml</code>文件内，查找范围取决于顶层的<code>x:Class</code>属性</li></ul><figure><img src="'+g+`" alt="image-20250301155421851" tabindex="0" loading="lazy"><figcaption>image-20250301155421851</figcaption></figure><p>这表明这个Page内的<code>X:Bind</code>会从<code>App2.MainPage</code>中查找。</p><hr><p>不过，事件的处理程序并不会因为<code>DataTemplate</code>和<code>ContentTemplate</code>而导致的查找范围改变！比较如下代码：</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ItemsRepeater.ItemTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">DataTemplate</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> x:DataType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;model:FruitModel&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">StackPanel</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Orientation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Horizontal&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Button</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Click</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;ButtonBase_OnClick&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Button</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> Click</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{x:Bind ButtonBase_OnClick}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">StackPanel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">DataTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ItemsRepeater.ItemTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个不会报错，而第二个会。</p><hr><p>然后，<code>x:Bind</code>还可以绑定到Static的东西上去。比如我在<code>xaml</code>里声明了引入一个命名空间：<code>xmlns:helper=&quot;using:App2.Helper&quot;</code></p><p>其中有这么一个static类：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ConverterHelper</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> string</span><span style="--shiki-light:#4078F2;--shiki-dark:#ABB2BF;"> Name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;} </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Shirasagi&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> string</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GreetingConvert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) =&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">$&quot;Hello, {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">}!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那我们可以这样使用它：<code>{x:Bind helper:ConverterHelper.Name}</code></p><p>函数绑定也是可以的：<code>{x:Bind helper:ConverterHelper.GreetingConvert(helper:ConverterHelper.Name})}</code></p><p>这对于一些可以重复使用的Converter而言非常好用。</p>`,134)]))}const m=s(A,[["render",o],["__file","2025-2-1st.html.vue"]]),u=JSON.parse(`{"path":"/sast-csharp/2025-2-1st.html","title":"[SAST C#] 一些补充","lang":"zh-CN","frontmatter":{"title":"[SAST C#] 一些补充","license":"CC BY-SA 4.0 International","date":"2025-01-24T00:00:00.000Z","category":["NJUPT SAST 南邮校科协"],"tag":["C#",".NET","WinUI","XAML"],"description":"一些补充 这次主要是补齐一些之前没讲的内容。 Null Check 文件 I/O C#提供了丰富的文件操作相关的API。 简单方便的文件读写操作 System.IO命名空间下的File类为我们提供了非常简单的文件读写方式。你可以在文档中找到接下来要用到的各个方法的用法，这里不详细介绍了。 写入 只需要使用File.WriteAllLines/File....","head":[["meta",{"property":"og:url","content":"https://blog.shirasagi.space/sast-csharp/2025-2-1st.html"}],["meta",{"property":"og:site_name","content":"Shirasagi's Blog"}],["meta",{"property":"og:title","content":"[SAST C#] 一些补充"}],["meta",{"property":"og:description","content":"一些补充 这次主要是补齐一些之前没讲的内容。 Null Check 文件 I/O C#提供了丰富的文件操作相关的API。 简单方便的文件读写操作 System.IO命名空间下的File类为我们提供了非常简单的文件读写方式。你可以在文档中找到接下来要用到的各个方法的用法，这里不详细介绍了。 写入 只需要使用File.WriteAllLines/File...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-08T19:39:30.000Z"}],["meta",{"property":"article:tag","content":"C#"}],["meta",{"property":"article:tag","content":".NET"}],["meta",{"property":"article:tag","content":"WinUI"}],["meta",{"property":"article:tag","content":"XAML"}],["meta",{"property":"article:published_time","content":"2025-01-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-08T19:39:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"[SAST C#] 一些补充\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-08T19:39:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Shirasagi\\",\\"url\\":\\"https://github.com/shirasagi0012\\"}]}"]]},"headers":[{"level":2,"title":"Null Check","slug":"null-check","link":"#null-check","children":[]},{"level":2,"title":"文件 I/O","slug":"文件-i-o","link":"#文件-i-o","children":[{"level":3,"title":"简单方便的文件读写操作","slug":"简单方便的文件读写操作","link":"#简单方便的文件读写操作","children":[]},{"level":3,"title":"更复杂的流式I/O","slug":"更复杂的流式i-o","link":"#更复杂的流式i-o","children":[]}]},{"level":2,"title":"x:Bind的一些高级用法","slug":"x-bind的一些高级用法","link":"#x-bind的一些高级用法","children":[{"level":3,"title":"函数绑定","slug":"函数绑定","link":"#函数绑定","children":[]},{"level":3,"title":"事件绑定","slug":"事件绑定","link":"#事件绑定","children":[]},{"level":3,"title":"属性查找","slug":"属性查找","link":"#属性查找","children":[]}]}],"git":{"createdTime":1740809827000,"updatedTime":1741462770000,"contributors":[{"name":"Shirasagi","username":"Shirasagi","email":"23011330+Shirasagi0012@users.noreply.github.com","commits":4,"url":"https://github.com/Shirasagi"}]},"readingTime":{"minutes":14.62,"words":4387},"filePathRelative":"sast-csharp/2025-2-1st.md","localizedDate":"2025年1月24日","excerpt":"\\n<p>这次主要是补齐一些之前没讲的内容。</p>\\n<h2>Null Check</h2>\\n<h2>文件 I/O</h2>\\n<p>C#提供了丰富的文件操作相关的API。</p>\\n<h3>简单方便的文件读写操作</h3>\\n<p><code>System.IO</code>命名空间下的<code>File</code>类为我们提供了非常简单的文件读写方式。你可以在<a href=\\"https://learn.microsoft.com/en-us/dotnet/api/system.io.file\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">文档中</a>找到接下来要用到的各个方法的用法，这里不详细介绍了。</p>","autoDesc":true}`);export{m as comp,u as data};

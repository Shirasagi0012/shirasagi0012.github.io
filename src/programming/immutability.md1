---
license: CC BY-SA 4.0 International
date: 2025-04-24
title: "不可变性"
tag:
  - C#
  - .NET
---

# 不可变性

程序就是一个状态机，程序的运行就是不断迁移到下一个状态的过程。程序运行时还会受到外界环境的干涉（用户交互，网络请求……）而改变状态。在并行运行的多线程程序中，代码执行的时序也会对运行结果产生影响。很显然，哪怕一个极其简单的程序都会有无穷无尽的运行状态。并且由于外界干涉，程序的状态是不可预测的。程序很有可能会进入某些不应存在的状态，产生未定义的行为，换句话说，出Bug了。由于程序的状态数量是天文数字，遍历所有可能的状态来查找可能的Bug是几乎不可能的。

既然许多Bug都源自不可预知的状态迁移，那么预防和解决这类Bug的一种思路就是限制状态的数量，最小化状态迁移的次数。状态少了，出现Bug的概率会降低，定位和修复Bug的难度也会下降。为达成这一目的，可以使用不可变性——不可变性（Immutability）是函数式编程中的一个核心概念。从字面上理解，不可变就是指“不会被改变”，这也意味着不会产生新的状态。

## 不可变模型

## 更多……

不可变性这一概念并不仅仅局限于编程语言与程序，它还在更多的领域发光发热。许多底层的部件都受益于不可变性带来的可靠性。

### 不可变基础设施

对于传统的可变基础设施，假设我们要将一个已部署了Apache的服务器更换为Nginx，需要先卸载Apache，再安装Nginx，然后配置好Nginx，最终上线。这一过程中，服务器经历了多次变更，因此我们说它是一个可变的基础设施。这种做法会导致一些问题：

- 遇到重大故障难以迅速重新构建基础设施。由于基础设施在不断改变，难以由标准初始化的服务器来重新构建起等效的服务。
- 不一致问题。在变更的过程中，会引入各种中间状态。随着改动次数增加，出现问题的概率也会上升。

这让它很难满足当下云原生对于快速部署和高可靠性的要求。不可变基础设施是云原生的一个重要技术，其思想的核心是，**任何基础设施的运行实例一旦创建之后就变成只读状态**，不得改变。如果需要更改或升级，应该修改配置文件后，重新部署一个等效的升级后的服务替换原有的。

通常会使用Docker这样的服务容器来实现这一点。容器的镜像发布后不会被改变，并且无任何隐含的依赖项。对于相同的镜像，你能预期它在不同环境能有相同的表现。构建镜像运行容器之后，如果出现问题，我们不会在容器内修改解决，而是修改`Dockerfile`在容器构建阶段去解决。从容器的角度看，**镜像就是一个不可变基础设施**。更新时，开发者只需要提供一个服务镜像，然后运维在服务器上的另一个容器部署，而非对原有的镜像做变更。这样，服务器与服务器之间，开发环境与生产环境之间的差异能实现最小化。

相比可变基础设施，不可变基础设施通过标准化描述文件（如 `yaml`、`dockerfile` 等）声明式地统一定义，同样的配置拉起的服务，绝对不可能出现不一致的情况。从此，我们可以快速拉起成千上万一模一样的服务，服务的版本升级、回滚也成为常态。

### 不可变操作系统

操作系统需要不断更新。多数桌面操作系统都是可变的，这意味着在更新的过程（甚至安装软件的过程）都会对系统本身造成更改，并且更改过程中会产生大量的中间状态。各位应该听过不少Windows更新失败、Arch Linux滚动更新完系统挂掉之类的故事了。借助还原点和文件系统的快照，能解决更新失败产生的问题，但是仍然不能保证更新后的系统是和预期一样可靠的。因此，新兴的操作系统逐渐变得不可变——这主要体现在系统分区只读。包括但不限于用于所有非桌面平台的Windows Core OS，ChromeOS，Android，iOS/iPadOS。还有一部分Linux发行版只需要通过声明式的配置就能完整配置操作系统与应用，并且能在其它设备上复现。



有了不可变保证的稳定性，我们能以声明式且可复现的方式构建其上的所有部件。这大大降低了部署服务/配置环境的难度。不可变似乎意味着不灵活与难以改变，但实际上有了其提供的稳定性，才能灵活的修改与更新。越底层的设施，越应该是不可变的，尤其是在软件快速迭代的当下。

## 总结



